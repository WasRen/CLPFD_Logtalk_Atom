".source.logtalk" :
  "directive:category":
  	body: '''
  		:- category(${1:name}).
  			$2
  		:- end_category.

  	'''
  	prefix: "cat"

  "directive:catrelation":
  	body: "${1|implements,extends,complements|}($2)"
  	description: "relations between categories"
  	prefix: "crel"
  "directive:object":
  	body: '''
  		:- object(${1:name}).
  			$2
  		:- end_object.

  	'''
  	prefix: "obj"

  "directive:objrelation":
  	body: "${1|imports,implements,extends,instantiates,specializes|}($2)"
  	description: "relations between objects"
  	prefix: "orel"
  "directive:prorelation":
  	body: "extends(${1})"
  	description: "relations between categories"
  	prefix: "ext"

  "directive:protocol":
  	body: '''
  		:- protocol(${1:name}).
  			$2
  		:- end_protocol.

  	'''
  	prefix: "pro"


  "directives:alias/2":
  	body: '''
  		:- alias(${1:Entity}, ${2:PredicateAliases}).

  	'''
  	description: '''
  		Template and modes
  		alias(@entity_identifier, +list(predicate_indicator_alias))
  		alias(@entity_identifier, +list(non_terminal_indicator_alias))

  		Description
  		Declares predicate and grammar rule non-terminal aliases. A predicate (non-terminal) alias is an alternative name for a predicate (non-terminal) declared or defined in an extended protocol, an implemented protocol, an extended category, an imported category, an extended prototype, an instantiated class, or a specialized class. Predicate aliases may be used to solve conflicts between imported or inherited predicates. It may also be used to give a predicate (non-terminal) a name more appropriated in its usage context. This directive may be used in objects, protocols, and categories.

  	'''
  	prefix: "alias"


  "directives:built_in/0":
  	body: '''
  		:- built_in$0.

  	'''
  	description: '''
  		Template and modes
  		built_in

  		Description
  		Declares an entity as built-in. Built-in entities cannot be redefined once loaded.

  	'''
  	prefix: "built_in"

  "directives:coinductive/1":
  	body: '''
  		:- coinductive(${1:Functor/Arity}).

  	'''
  	description: '''
  		Template and modes
  		coinductive(+predicate_indicator_term)
  		coinductive(+coinductive_predicate_template_term)

  		Description
  		This is an experimental directive, used for declaring coinductive predicates. Requires a back-end Prolog compiler with minimal support for cyclic terms. The current implementation of coinduction allows the generation of only the basic cycles but all valid solutions should be recognized. Use a predicate indicator as argument when all the coinductive predicate arguments are relevant for coinductive success. Use a template when only some coinductive predicate arguments (represented by a "+") should be considered when testing for coinductive success (represent the arguments that should be disregarded by a "-"). It's possible to define local coinductive_success_hook/2 or coinductive_success_hook/1 predicates that are automatically called with the coinductive predicate term resulting from a successful unification with an ancestor goal as first argument. The second argument, when present, is the coinductive hypothesis (i.e. the ancestor goal) used. These hook predicates can provide an alternative to the use of tabling when defining some coinductive predicates. There is no overhead when these hook predicates are not defined.

  	'''
  	prefix: "coinductive"



  "directives:discontiguous/1":
  	body: '''
  		:- discontiguous(${1:Functor/Arity}).

  	'''
  	description: '''
  		Template and modes
  		discontiguous(+predicate_indicator_term)
  		discontiguous(+non_terminal_indicator_term)

  		Description
  		Declares discontiguous predicates and discontiguous grammar rule non-terminals. The use of this directive should be avoided as not all backend Prolog compilers support discontiguous predicates.

  	'''
  	prefix: "discontiguous"

  "directives:dynamic/0":
  	body: '''
  		:- dynamic$0.

  	'''
  	description: '''
  		Template and modes
  		dynamic

  		Description
  		Declares an entity and its contents as dynamic. Dynamic entities can be abolished at runtime.

  	'''
  	prefix: "dynamic0"


  "directives:dynamic/1":
  	body: '''
  		:- dynamic(${1:Functor/Arity}).

  	'''
  	description: '''
  		Template and modes
  		dynamic(+qualified_predicate_indicator_term)
  		dynamic(+qualified_non_terminal_indicator_term)

  		Description
  		Declares dynamic predicates and dynamic grammar rule non-terminals. Note that an object can be static and have both static and dynamic predicates/non-terminals. Dynamic predicates cannot be declared as synchronized. When the dynamic predicates are local to an object, declaring them also as private predicates allows the Logtalk compiler to generate optimized code for asserting and retracting predicate clauses. Categories can also contain dynamic predicate directives but cannot contain clauses for dynamic predicates.

  	'''
  	prefix: "dynamic1"

  "directives:elif/1":
  	body: '''
  		:- elif(${1:Goal}).

  	'''
  	description: '''
  		Template and modes
  		elif(@callable)

  		Description
  		Supports embedded conditionals when performing conditional compilation. The code following the directive is compiled if Goal is true. The goal is subjected to goal expansion when the directive occurs in a source file.

  	'''
  	prefix: "elif"

  "directives:else/0":
  	body: '''
  		:- else$0.

  	'''
  	description: '''
  		Template and modes
  		else

  		Description
  		Starts a else branch when performing conditional compilation.

  	'''
  	prefix: "else"


  "directives:encoding/1":
  	body: '''
  		:- encoding(${1:Encoding}).

  	'''
  	description: '''
  		Template and modes
  		encoding(+atom)

  		Description
  		Declares the source file text encoding. This is an experimental source file directive, which is only supported on some back-end Prolog compilers. When used, this directive must be the first term in the source file in the first line. Currently recognized encodings values include 'US-ASCII', 'ISO-8859-1', 'ISO-8859-2', 'ISO-8859-15', 'UCS-2', 'UCS-2LE', 'UCS-2BE', 'UTF-8', 'UTF-16', 'UTF-16LE', 'UTF-16BE', 'UTF-32', 'UTF-32LE', 'UTF-32BE', 'Shift_JIS', and 'EUC-JP'. Be sure to use an encoding supported by the chosen back-end Prolog compiler (whose adapter file must define a table that translates between the Logtalk and Prolog-specific atoms that represent each supported encoding). When writing portable code that cannot be expressed using ASCII, 'UTF-8' is usually the best choice.

  	'''
  	prefix: "encoding"


  "directives:if/1":
  	body: '''
  		:- if(${1:Goal}).

  	'''
  	description: '''
  		Template and modes
  		if(@callable)

  		Description
  		Starts conditional compilation. The code following the directive is compiled if Goal is true. The goal is subjected to goal expansion when the directive occurs in a source file.

  	'''
  	prefix: "if"


  "directives:include/1":
  	body: '''
  		:- include(${1:File}).

  	'''
  	description: '''
  		Template and modes
  		include(@source_file_name)

  		Description
  		Includes a file contents, which must be valid terms, at the place of occurrence of the directive. The file can be specified as a relative path, an absolute path, or using library notation and is expanded as a source file name. Relative paths are interpreted as relative to the path of the file contining the directive.

  	'''
  	prefix: "include"

  "directives:info/1":
  	body: '''
  		:- info(${1:List}).

  	'''
  	description: '''
  		Template and modes
  		info(+entity_info_list)

  		Description
  		Documentation directive for objects, protocols, and categories. The directive argument is a list of pairs using the format Key is Value. See the documenting Logtalk programs section for a description of the default keys.

  	'''
  	prefix: "info1"



  "directives:info/2":
  	body: '''
  		:- info(${1:Functor/Arity}, ${2:List}).

  	'''
  	description: '''
  		Template and modes
  		info(+predicate_indicator, +predicate_info_list)
  		info(+non_terminal_indicator, +predicate_info_list)

  		Description
  		Documentation directive for predicates and grammar rule non-terminals. The first argument is either a predicate indicator or a grammar rule non-terminal indicator. The second argument is a list of pairs using the format Key is Value. See the documenting Logtalk programs section for a description of the default keys.

  	'''
  	prefix: "info2"

  "directives:initialization/1":
  	body: '''
  		:- initialization(${1:Goal}).

  	'''
  	description: '''
  		Template and modes
  		initialization(@callable)

  		Description
  		When used within an object, this directive defines a goal to be called immediately after the object has been loaded into memory. When used at a global level within a source file, this directive defines a goal to be called immediately after the compiled source file is loaded into memory.

  	'''
  	prefix: "initialization"

  "directives:meta_non_terminal/1":
  	body: '''
  		:- meta_non_terminal(${1:MetaNonTerminalTemplate}).

  	'''
  	description: '''
  		Template and modes
  		meta_non_terminal(+meta_non_terminal_template_term)

  		meta_non_terminal(+object_identifier::+meta_non_terminal_template_term)
  		meta_non_terminal(+category_identifier::+meta_non_terminal_template_term)

  		meta_non_terminal(+module_identifier:+meta_non_terminal_template_term)

  		Description
  		Declares meta-non-terminals, i.e., non-terminals that have arguments that will be called as non-terminals (or grammar rule bodies). An argument may also be a closure instead of a goal if the non-terminal uses the call//1-N Logtalk built-in methods to construct and call the actual non-terminal from the closure and the additional arguments.

  	'''
  	prefix: "meta_non_terminal"


  "directives:meta_predicate/1":
  	body: '''
  		:- meta_predicate(${1:MetaPredicateTemplate}).

  	'''
  	description: '''
  		Template and modes
  		meta_predicate(+meta_predicate_template_term)

  		meta_predicate(+object_identifier::+meta_predicate_template_term)
  		meta_predicate(+category_identifier::+meta_predicate_template_term)

  		meta_predicate(+module_identifier:+meta_predicate_template_term)

  		Description
  		Declares meta-predicates, i.e., predicates that have arguments that will be called as goals. An argument may also be a closure instead of a goal if the meta-predicate uses the call/N Logtalk built-in methods to construct and call the actual goal from the closure and the additional arguments.

  	'''
  	prefix: "meta_predicate"

  "directives:mode/2":
  	body: '''
  		:- mode(${1:Mode}, ${2:NumberOfProofs}).

  	'''
  	description: '''
  		Template and modes
  		mode(+predicate_mode_term, +number_of_proofs)
  		mode(+non_terminal_mode_term, +number_of_proofs)

  		Description
  		Most predicates can be used with several instantiations modes. This directive enables the specification of each instantiation mode and the corresponding number of proofs (not necessarily distinct solutions). You may also use this directive for documenting grammar rule non-terminals.

  	'''
  	prefix: "mode"

  "directives:multifile/1":
  	body: '''
  		:- multifile(${1:Functor/Arity}).

  	'''
  	description: '''
  		Template and modes
  		multifile(+qualified_predicate_indicator_term)
  		multifile(+qualified_non_terminal_indicator_term)

  		Description
  		Declares multifile predicates and multifile grammar rule non-terminals. In the case of object or category multifile predicates, the predicate (or non-terminal) must also have a scope directive in the object or category holding its primary declaration (i.e. the declaration without the Entity:: prefix). Entities holding multifile predicate primary declarations must be compiled and loaded prior to any entities contributing with clauses for the multifile predicates.

  	'''
  	prefix: "multifile"

  "directives:op/3":
  	body: '''
  		:- op(${1:Precedence}, ${2:Associativity}, ${3:Operator}).

  	'''
  	description: '''
  		Template and modes
  		op(+integer, +associativity, +atom_or_atom_list)

  		Description
  		Declares operators. Operators declared inside entities have local scope. Global operators can be declared inside a source file by writing the respective directives before the entity opening directives.

  	'''
  	prefix: "op"


  "directives:private/1":
  	body: '''
  		:- private(${1:Functor/Arity}).

  	'''
  	description: '''
  		Template and modes
  		private(+predicate_indicator_term)
  		private(+non_terminal_indicator_term)
  		private(+operator_declaration)

  		Description
  		Declares private predicates, private grammar rule non-terminals, and private operators. A private predicate can only be called from the object containing the private directive. A private non-terminal can only be used in a call of the phrase/2 and phrase/3 methods from the object containing the private directive.

  	'''
  	prefix: "private1"

  "directives:protected/1":
  	body: '''
  		:- protected(${1:Functor/Arity}).

  	'''
  	description: '''
  		Template and modes
  		protected(+predicate_indicator_term)
  		protected(+non_terminal_indicator_term)
  		protected(+operator_declaration)

  		Description
  		Declares protected predicates, protected grammar rule non-terminals, and protected operators. A protected predicate can only be called from the object containing the directive or from an object that inherits the directive. A protected non-terminal can only be used as an argument in a phrase/2 and phrase/3 calls from the object containing the directive or from an object that inherits the directive. Protected operators are not inherited but declaring them provides useful information for defining descendant objects.

  	'''
  	prefix: "protected1"

  "directives:public/1":
  	body: '''
  		:- public(${1:Functor/Arity}).

  	'''
  	description: '''
  		Template and modes
  		public(+predicate_indicator_term)
  		public(+non_terminal_indicator_term)
  		public(+operator_declaration)

  		Description
  		Declares public predicates, public grammar rule non-terminals, and public operators. A public predicate can be called from any object. A public non-terminal can be used as an argument in phrase/2 and phrase/3 calls from any object. Public operators are not exported but declaring them provides useful information for defining client objects.

  	'''
  	prefix: "public1"

  "directives:set_logtalk_flag/2":
  	body: '''
  		:- set_logtalk_flag(${1:Flag}, ${2:Value}).

  	'''
  	description: '''
  		Template and modes
  		set_logtalk_flag(+atom, +nonvar)

  		Description
  		Sets Logtalk flag values. The scope of this directive is the entity or the source file containing it. For global scope, use the corresponding set_logtalk_flag/2 built-in predicate within an initialization/1 directive.

  	'''
  	prefix: "set_logtalk_flag"

  "directives:synchronized/1":
  	body: '''
  		:- synchronized(${1:Functor/Arity}).

  	'''
  	description: '''
  		Template and modes
  		synchronized(+predicate_indicator_term)
  		synchronized(+non_terminal_indicator_term)

  		Description
  		Declares synchronized predicates and synchronized grammar rule non-terminals. A synchronized predicate (or synchronized non-terminal) is protected by a mutex in order to allow for thread synchronization when proving a call to the predicate (or non-terminal). All predicates (and non-terminals) declared in the same synchronized directive share the same mutex. In order to use a separate mutex for each predicate (non-terminal) so that they are independently synchronized, a per-predicate synchronized directive must be used.

  	'''
  	prefix: "synchronized"


  "directives:threaded/0":
  	body: '''
  		:- threaded$0.

  	'''
  	description: '''
  		Template and modes
  		threaded

  		Description
  		Declares that an object supports concurrent calls and asynchronous messages. Any object containing calls to the built-in multi-threading predicates (or importing a category that contains such calls) must include this directive.

  	'''
  	prefix: "threaded"

  "directives:use_module/2":
  	body: '''
  		:- use_module(${1:Module}, ${2:Predicates}).

  	'''
  	description: '''
  		Template and modes
  		use_module(+module_identifier, +predicate_indicator_list)

  		Description
  		This directive declares that all calls (made from predicates defined in the category or object containing the directive) to the specified predicates are to be interpreted as calls to explicitly-qualified module predicates. Thus, this directive may be used to simplify writing of predicate definitions by allowing the programmer to omit the Module: prefix when using the predicates listed in the directive (as long as the predicate calls do not occur as arguments for non-standard Prolog meta-predicates not declared on the adapter files). It is also possible to include operator declarations, op(Precedence, Associativity, Operator), in the second argument.

  	'''
  	prefix: "use_module"

  "directives:uses/2":
  	body: '''
  		:- uses(${1:Object}, ${2:Predicates}).

  	'''
  	description: '''
  		Template and modes
  		uses(+object_identifier, +predicate_indicator_list)
  		uses(+object_identifier, +predicate_indicator_alias_list)

  		uses(+object_identifier, +non_terminal_indicator_list)
  		uses(+object_identifier, +non_terminal_indicator_alias_list)

  		Description
  		Declares that all calls made from predicates (or non-terminals) defined in the category or object containing the directive to the specified predicates (or non-terminals) are to be interpreted as messages to the specified object. Thus, this directive may be used to simplify writing of predicate definitions by allowing the programmer to omit the Object:: prefix when using the predicates listed in the directive (as long as the  calls do not occur as arguments for non-standard Prolog meta-predicates not declared on the adapter files). It is also possible to include operator declarations, op(Precedence, Associativity, Operator), in the second argument.

  	'''
  	prefix: "uses"


  "instance0":
  	body: '''

  		:- object(${1:Instance},
  			implements(${2:Protocol}),
  			imports(${3:Category}),
  			instantiates(${4:Class})).

  			:- info([
  				version is 1.0,
  				author is '${5:Author}',
  				date is ${6:$CURRENT_YEAR}/${7:$CURRENT_MONTH}/${8:$CURRENT_DATE},
  				comment is '${9:Description}'
  			]).

  		$0

  		:- end_object.

  	'''
  	description: "Instance with all"
  	prefix: "instance0"

  "instance1":
  	body: '''

  		:- object(${1:Instance},
  			imports(${2:Category}),
  			instantiates(${3:Class})).

  			:- info([
  				version is 1.0,
  				author is '${4:Author}',
  				date is ${5:$CURRENT_YEAR}/${6:$CURRENT_MONTH}/${7:$CURRENT_DATE},
  				comment is '${8:Description}'
  			]).

  		$0

  		:- end_object.

  	'''
  	description: "Instance with category"
  	prefix: "instance1"

  "instance2":
  	body: '''

  		:- object(${1:Instance},
  			implements(${2:Protocol}),
  			instantiates(${3:Class})).

  			:- info([
  				version is 1.0,
  				author is '${4:Author}',
  				date is ${5:$CURRENT_YEAR}/${6:$CURRENT_MONTH}/${7:$CURRENT_DATE},
  				comment is '${8:Description}'
  			]).

  		$0

  		:- end_object.

  	'''
  	description: "Instance with protocol"
  	prefix: "instance2"

  "instance3":
  	body: '''

  		:- object(${1:Instance},
  			instantiates(${2:Class})).

  			:- info([
  				version is 1.0,
  				author is '${3:Author}',
  				date is ${4:$CURRENT_YEAR}/${5:$CURRENT_MONTH}/${6:$CURRENT_DATE},
  				comment is '${7:Description}'
  			]).

  		$0

  		:- end_object.

  	'''
  	description: "Instance"
  	prefix: "instance3"

  "methods:abolish/1":
  	body: '''
  		abolish(${1:Predicate})$0

  	'''
  	description: '''
  		Template and modes
  		abolish(+predicate_indicator)

  		Description
  		Abolishes a runtime declared dynamic predicate or a local dynamic predicate. When the predicate indicator for Head is declared in a uses/2 or use_module/2 directive, the predicate is abolished in the referenced object or module. Otherwise the predicate is abolished in an object's database. In the case of objects, only predicates that are dynamically declared (using a call to the asserta/1 or assertz/1 built-in methods) can be abolished.

  	'''
  	prefix: "abolish"

  "methods:after/3":
  	body: '''
  		after(${1:Object}, ${2:Message}, ${3:Sender})$0

  	'''
  	description: '''
  		Template and modes
  		after(?object_identifier, ?callable, ?object_identifier)

  		Description
  		User-defined method for handling after events. This method is declared in the monitoring built-in protocol as a public predicate. Note that you can make its scope protected or private by using, respectively, protected or private implementation of the monitoring protocol.

  	'''
  	prefix: "after"

  "methods:ask_question/5":
  	body: '''
  		ask_question(${1:Question}, ${2:Kind}, ${3:Component}, ${4:Check}, ${5:Answer})$0

  	'''
  	description: '''
  		Template and modes
  		ask_question(+nonvar, +nonvar, +nonvar, +callable, -term)

  		Description
  		Built-in method for asking a question represented by a term, Question, which is converted to the question text using the logtalk::message_tokens(Question, Component) hook predicate. This method is declared in the logtalk built-in object as a public predicate. The default question prompt and the input stream used for each Kind-Component pair can be found using the logtalk::question_prompt_stream(Kind, Component, Prompt, Stream) hook predicate. The Check argument is a closure that is converted into a checking goal by extending it with the user supplied answer. This predicate implements a read-loop that terminates when the checking predicate succeeds.

  	'''
  	prefix: "ask_question"

  "methods:asserta/1":
  	body: '''
  		asserta(${1:Head})$0

  	'''
  	description: '''
  		Template and modes
  		asserta(+clause)

  		Description
  		Asserts a clause as the first one for a dynamic predicate. When the predicate indicator for Head is declared in a uses/2 or use_module/2 directive, the clause is asserted in the referenced object or module. Otherwise the clause is asserted for an object's dynamic predicate. If the predicate is not previously declared (using a scope directive), then a dynamic predicate declaration is added to the object (assuming that we are asserting locally or that the compiler flag dynamic_declarations was set to allow when the object was created or compiled).

  	'''
  	prefix: "asserta"

  "methods:assertz/1":
  	body: '''
  		assertz(${1:Head})$0

  	'''
  	description: '''
  		Template and modes
  		assertz(+clause)

  		Description
  		Asserts a clause as the last one for a dynamic predicate. When the predicate indicator for Head is declared in a uses/2 or use_module/2 directive, the clause is asserted in the referenced object or module. Otherwise the clause is asserted for an object's dynamic predicate. If the predicate is not previously declared (using a scope directive), then a dynamic predicate declaration is added to the object (assuming that we are asserting locally or that the compiler flag dynamic_declarations was set to allow when the object was created or compiled).

  	'''
  	prefix: "assertz"

  "methods:bagof/3":
  	body: '''
  		bagof(${1:Template}, ${2:Goal}, ${3:List})$0

  	'''
  	description: '''
  		Template and modes
  		bagof(@term, +callable, -list)

  		Description
  		Collects a bag of solutions for the goal for each set of instantiations of the free variables in the goal. The order of the elements in the bag follows the order of the goal solutions. The free variables in the goal are the variables that occur in the goal but not in the template. Free variables can be ignored, however, by using the ^/2 existential qualifier. For example, if T is term containing all the free variables that we want to ignore, we can write T^Goal. Note that the term T can be written as V1^V2^....

  	'''
  	prefix: "bagof"

  "methods:before/3":
  	body: '''
  		before(${1:Object}, ${2:Message}, ${3:Sender})$0

  	'''
  	description: '''
  		Template and modes
  		before(?object_identifier, ?callable, ?object_identifier)

  		Description
  		User-defined method for handling before events. This method is declared in the monitoring built-in protocol as a public predicate. Note that you can make its scope protected or private by using, respectively, protected or private implementation of the monitoring protocol.

  	'''
  	prefix: "before"

  "methods:call//1-N":
  	body: '''
  		call(${1:Closure})$0

  	'''
  	description: '''
  		Template and modes
  		call(+callable)
  		call(+callable, ?term)
  		call(+callable, ?term, ?term)
  		...

  		Description
  		This non-terminal takes a closure and is processed by appending the input list of tokens and the list of remaining tokens to the arguments of the closure. This built-in non-terminal is interpreted as a private non-terminal and thus cannot be used as a message to an object. When using a back-end Prolog compiler supporting a module system, calls in the format call(Module:Closure) may also be used. By using as argument a lambda expression, this built-in non-terminal provides controlled access to the input list of tokens and to the list of the remaining tokens processed by the grammar rule containing the call.

  	'''
  	prefix: "call"

  "methods:call/1-N":
  	body: '''
  		call(${1:Goal})$0

  	'''
  	description: '''
  		Template and modes
  		call(+callable)
  		call(+callable, ?term)
  		call(+callable, ?term, ?term)
  		...

  		Description
  		Calls a goal, which might be constructed by appending additional arguments to a closure. The upper limit for N depends on the upper limit for the arity of a compound term of the back-end Prolog compiler. This built-in meta-predicate is declared as a private method and thus cannot be used as a message to an object. The Closure argument can also be a lambda expression or a Logtalk control construct. When using a back-end Prolog compiler supporting a module system, calls in the format call(Module:Closure, Arg1, ...) may also be used.

  	'''
  	prefix: "call1N"

  "methods:catch/3":
  	body: '''
  		catch(${1:Goal}, ${2:Catcher}, ${3:Recovery})$0

  	'''
  	description: '''
  		Template and modes
  		catch(?callable, ?term, ?term)

  		Description
  		Catches exceptions thrown by a goal. See the Prolog ISO standard definition. This built-in meta-predicate is declared as a private method and thus cannot be used as a message to an object.

  	'''
  	prefix: "catch3"

  "methods:clause/2":
  	body: '''
  		clause(${1:Head}, ${2:Body})$0

  	'''
  	description: '''
  		Template and modes
  		clause(+callable, ?body)

  		Description
  		Enumerates, by backtracking, the clauses of a dynamic predicate. When the predicate indicator for Head is declared in a uses/2 or use_module/2 directive, the predicate enumerates the clauses in the referenced object or module. Otherwise it enumerates the clauses for an object's dynamic predicate.

  	'''
  	prefix: "clause2"

  "methods:coinductive_success_hook/1-2":
  	body: '''
  		coinductive_success_hook(${1:Head}, ${2:Hypothesis})$0

  	'''
  	description: '''
  		Template and modes
  		coinductive_success_hook(+callable, +callable)
  		coinductive_success_hook(+callable)

  		Description
  		User-defined hook predicates that are automatically called in case of coinductive success when proving a query for a coinductive predicates. The hook predicates are called with the head of the coinductive predicate on coinductive success and, optionally, with the hypothesis used that to reach coinductive success.

  	'''
  	prefix: "coinductive_success_hook"

  "methods:context/1":
  	body: '''
  		context(${1:Context})$0

  	'''
  	description: '''
  		Template and modes
  		context(--callable)

  		Description
  		Returns the execution context for a predicate call using the format logtalk(Call,ExecutionContext). Mainly used for providing a default error context when type-checking predicate arguments. The ExecutionContext should be regarded as an opaque term, which can be decoded using the logtalk::execution_context/7 predicate. Calls to this predicate are inlined at compilation time.

  	'''
  	prefix: "context1"

  "methods:current_op/3":
  	body: '''
  		current_op(${1:Priority}, ${2:Specifier}, ${3:Operator})$0

  	'''
  	description: '''
  		Template and modes
  		current_op(?operator_priority, ?operator_specifier, ?atom)

  		Description
  		Enumerates, by backtracking, the visible operators declared for an object. Operators not declared using a scope directive are not enumerated.

  	'''
  	prefix: "current_op3"

  "methods:current_predicate/1":
  	body: '''
  		current_predicate(${1:Predicate})$0

  	'''
  	description: '''
  		Template and modes
  		current_predicate(?predicate_indicator)

  		Description
  		Enumerates, by backtracking, visible user predicates. When the predicate is declared in a uses/2 or use_module/2 directive, predicates are enumerated for the referenced object or module. Otherwise predicates are enumerated for an object. In the case of objects, predicates not declared using a scope directive are not enumerated.

  	'''
  	prefix: "current_predicate1"

  "methods:eos//0":
  	body: '''
  		eos$0$0

  	'''
  	description: '''
  		Template and modes
  		eos

  		Description
  		This non-terminal matches the end-of-input. It is implemented by checking that the implicit difference list unifies with []-[].

  	'''
  	prefix: "eos0"

  "methods:expand_goal/2":
  	body: '''
  		expand_goal(${1:Goal}, ${2:ExpandedGoal})$0

  	'''
  	description: '''
  		Template and modes
  		expand_goal(?term, ?term)

  		Description
  		Expands a goal.

  	'''
  	prefix: "expand_goal2"

  "methods:expand_term/2":
  	body: '''
  		expand_term(${1:Term}, ${2:Expansion})$0

  	'''
  	description: '''
  		Template and modes
  		expand_term(?term, ?term)

  		Description
  		Expands a term. The most common use is to expand a grammar rule into a clause. Users may override the default Logtalk grammar rule translator by defining clauses for the term_expansion/2 hook predicate.

  	'''
  	prefix: "expand_term2"

  "methods:findall/3":
  	body: '''
  		findall(${1:Template}, ${2:Goal}, ${3:List})$0

  	'''
  	description: '''
  		Template and modes
  		findall(?term, +callable, ?list)

  		Description
  		Collects a list of solutions for the goal. The order of the elements in the list follows the order of the goal solutions. It succeeds returning an empty list when the goal have no solutions.

  	'''
  	prefix: "findall3"

  "methods:findall/4":
  	body: '''
  		findall(${1:Template}, ${2:Goal}, ${3:List}, ${4:Tail})$0

  	'''
  	description: '''
  		Template and modes
  		findall(?term, +callable, ?list, +list)

  		Description
  		Variant of the findall/3 method that allows passing the tail of the results list. It succeeds returning the  tail argument when the goal have no solutions.

  	'''
  	prefix: "findall4"

  "methods:forall/2":
  	body: '''
  		forall(${1:Generator}, ${2:Test})$0

  	'''
  	description: '''
  		Template and modes
  		forall(+callable, +callable)

  		Description
  		For all solutions of Generator, Test is true. This built-in meta-predicate is declared as a private method and thus cannot be used as a message to an object.

  	'''
  	prefix: "forall2"

  "methods:forward/1":
  	body: '''
  		forward(${1:Message})$0

  	'''
  	description: '''
  		Template and modes
  		forward(+callable)

  		Description
  		User-defined method for forwarding unknown messages sent to an object (using the ::/2 control construct), automatically called by the runtime when defined. This method is declared in the forwarding built-in protocol as a public predicate. Note that you can make its scope protected or private by using, respectively, protected or private implementation of the forwarding protocol.

  	'''
  	prefix: "forward"

  "methods:goal_expansion/2":
  	body: '''
  		goal_expansion(${1:Goal}, ${2:ExpandedGoal})$0

  	'''
  	description: '''
  		Template and modes
  		goal_expansion(+callable, -callable)

  		Description
  		Defines an expansion for a goal. The first argument is the goal to be expanded. The expanded goal is returned in the second argument. This predicate is called recursively on the expanded goal until a fixed point is reached. Thus, care must be taken to avoid compilation loops. This predicate, when defined and within scope, is automatically called by the expand_goal/2 method. Use of this predicate by the expand_goal/2 method may be restricted by changing its default public scope.

  	'''
  	prefix: "goal_expansion2"

  "methods:ignore/1":
  	body: '''
  		ignore(${1:Goal})$0

  	'''
  	description: '''
  		Template and modes
  		ignore(+callable)

  		Description
  		This predicate succeeds whether its argument succeeds or fails and it is not re-executable. This built-in meta-predicate is declared as a private method and thus cannot be used as a message to an object.

  	'''
  	prefix: "ignore1"

  "methods:message_hook/4":
  	body: '''
  		message_hook(${1:Message}, ${2:Kind}, ${3:Component}, ${4:Tokens})$0

  	'''
  	description: '''
  		Template and modes
  		message_hook(@nonvar, @nonvar, @nonvar, @list(nonvar))

  		Description
  		User-defined hook method for intercepting printing of a message, declared in the logtalk built-in object as a public, multifile, and dynamic predicate. This hook method is automatically called by the print_message/3 method. When the call succeeds, the print_message/3 method assumes that the message have been successfully printed.

  	'''
  	prefix: "message_hook4"

  "methods:message_prefix_stream/4":
  	body: '''
  		message_prefix_stream(${1:Kind}, ${2:Component}, ${3:Prefix}, ${4:Stream})$0

  	'''
  	description: '''
  		Template and modes
  		message_prefix_stream(?nonvar, ?nonvar, ?atom, ?stream_or_alias)

  		Description
  		User-defined hook method for specifying the default prefix and stream for printing a message for a given kind and component. This method is declared in the logtalk built-in object as a public, multifile, and dynamic predicate.

  	'''
  	prefix: "message_prefix_stream4"

  "methods:message_tokens//2":
  	body: '''
  		message_tokens(${1:Message}, ${2:Component})$0

  	'''
  	description: '''
  		Template and modes
  		message_tokens(+nonvar, +nonvar)

  		Description
  		User-defined non-terminal hook used to rewrite a message term into a list of tokens and declared in the logtalk built-in object as a public, multifile, and dynamic non-terminal. The list of tokens can be printed by calling the print_message_tokens/3 method. This non-terminal hook is automatically called by the print_message/3 method.

  	'''
  	prefix: "message_tokens2"

  "methods:once/1":
  	body: '''
  		once(${1:Goal})$0

  	'''
  	description: '''
  		Template and modes
  		once(+callable)

  		Description
  		This predicate behaves as call(Goal) but it is not re-executable. This built-in meta-predicate is declared as a private method and thus cannot be used as a message to an object.

  	'''
  	prefix: "once1"

  "methods:parameter/2":
  	body: '''
  		parameter(${1:Number}, ${2:Term})$0

  	'''
  	description: '''
  		Template and modes
  		parameter(+integer, ?term)

  		Description
  		Used in parametric objects (and parametric categories), this private method provides runtime access to the parameter values of the entity that contains the predicate clause whose body is being executed by using the argument number in the entity identifier. This predicate is implemented as a unification between its second argument and the corresponding implicit execution-context argument in the predicate containing the call. This unification occurs at the clause head when the second argument is not instantiated (the most common case). When the second argument is instantiated, the unification must be delayed to runtime and thus occurs at the clause body. See also this/1.

  	'''
  	prefix: "parameter2"

  "methods:phrase//1":
  	body: '''
  		phrase(${1:NonTerminal})$0

  	'''
  	description: '''
  		Template and modes
  		phrase(+callable)

  		Description
  		This non-terminal takes a non-terminal or a grammar rule body and parses it using the current implicit list of tokens. A common use is to wrap what otherwise would be a naked variable in a grammar rule body.

  	'''
  	prefix: "phrase1"

  "methods:phrase/2":
  	body: '''
  		phrase(${1:GrammarRuleBody}, ${2:Input})$0

  	'''
  	description: '''
  		Template and modes
  		phrase(+callable, ?list)

  		Description
  		True when the GrammarRuleBody grammar rule body can be applied to the Input list of tokens. In the most common case, GrammarRuleBody is a non-terminal defined by a grammar rule. This built-in method is declared private and thus cannot be used as a message to an object. When using a back-end Prolog compiler supporting a module system, calls in the format phrase(Module:GrammarRuleBody, Input) may also be used.

  	'''
  	prefix: "phrase2"

  "methods:phrase/3":
  	body: '''
  		phrase(${1:GrammarRuleBody}, ${2:Input}, ${3:Rest})$0

  	'''
  	description: '''
  		Template and modes
  		phrase(+callable, ?list, ?list)

  		Description
  		True when the GrammarRuleBody grammar rule body can be applied to the Input-Rest difference list of tokens. In the most common case, GrammarRuleBody is a non-terminal defined by a grammar rule. This built-in method is declared private and thus cannot be used as a message to an object. When using a back-end Prolog compiler supporting a module system, calls in the format phrase(Module:GrammarRuleBody, Input, Rest) may also be used.

  	'''
  	prefix: "phrase3"

  "methods:predicate_property/2":
  	body: '''
  		predicate_property(${1:Predicate}, ${2:Property})$0

  	'''
  	description: '''
  		Template and modes
  		predicate_property(+callable, ?predicate_property)

  		Description
  		Enumerates, by backtracking, the properties of a visible predicate. When the predicate indicator for Predicate is declared in a uses/2 or use_module/2 directive, properties are enumerated for the referenced object or module predicate. Otherwise properties are enumerated for an object predicate. In the case of objects, properties for predicates not declared using a scope directive are not enumerated. The valid predicate properties are listed in the language grammar.

  	'''
  	prefix: "predicate_property2"

  "methods:print_message/3":
  	body: '''
  		print_message(${1:Kind}, ${2:Component}, ${3:Term})$0

  	'''
  	description: '''
  		Template and modes
  		print_message(+nonvar, +nonvar, +nonvar)

  		Description
  		Built-in method for printing a message represented by a term, which is converted to the message text using the logtalk::message_tokens(Term, Component) hook non-terminal. This method is declared in the logtalk built-in object as a public predicate. The line prefix and the output stream used for each Kind-Component pair can be found using the logtalk::message_prefix_stream(Kind, Component, Prefix, Stream) hook predicate.

  	'''
  	prefix: "print_message3"

  "methods:print_message_token/4":
  	body: '''
  		print_message_token(${1:Stream}, ${2:Prefix}, ${3:Token}, ${4:Tokens})$0

  	'''
  	description: '''
  		Template and modes
  		print_message_token(@stream_or_alias, @atom, @nonvar, @list(nonvar))

  		Description
  		User-defined hook method for printing a message token, declared in the logtalk built-in object as a public, multifile, and dynamic predicate. It allows the user to intercept the printing of a message token. This hook method is automatically called by the print_message_tokens/3 built-in method for each token.

  	'''
  	prefix: "print_message_token4"

  "methods:print_message_tokens/3":
  	body: '''
  		print_message_tokens(${1:Stream}, ${2:Prefix}, ${3:Tokens})$0

  	'''
  	description: '''
  		Template and modes
  		print_message_tokens(@stream_or_alias, +atom, @list(nonvar))

  		Description
  		Built-in method for printing a list of message tokens, declared in the logtalk built-in object as a public predicate. This method is automatically called by the print_message/3 method (assuming that the message was not intercepted by a message_hook/4 definition) and calls the user-defined hook predicate print_message_token/4 for each token. When a call to this hook predicate succeeds, the print_message_tokens/3 predicate assumes that the token have been printed. When the call fails, the print_message_tokens/3 predicate uses a default printing procedure for the token.

  	'''
  	prefix: "print_message_tokens3"

  "methods:question_hook/6":
  	body: '''
  		question_hook(${1:Question}, ${2:Kind}, ${3:Component}, ${4:Tokens}, ${5:Check}, ${6:Answer})$0

  	'''
  	description: '''
  		Template and modes
  		question_hook(+nonvar, +nonvar, +nonvar, +list(nonvar), +callable, -term)

  		Description
  		User-defined hook method for intercepting asking a question, declared in the logtalk built-in object as a public, multifile, and dynamic predicate. This hook method is automatically called by the ask_question/5 method. When the call succeeds, the ask_question/5 method assumes that the question have been successfully asked and replied.

  	'''
  	prefix: "question_hook6"

  "methods:question_prompt_stream/4":
  	body: '''
  		question_prompt_stream(${1:Kind}, ${2:Component}, ${3:Prompt}, ${4:Stream})$0

  	'''
  	description: '''
  		Template and modes
  		question_prompt_stream(?nonvar, ?nonvar, ?atom, ?stream_or_alias)

  		Description
  		User-defined hook method for specifying the default prompt and input stream for asking a question for a given kind and component. This method is declared in the logtalk built-in object as a public, multifile, and dynamic predicate.

  	'''
  	prefix: "question_prompt_stream4"

  "methods:retract/1":
  	body: '''
  		retract(${1:Head})$0

  	'''
  	description: '''
  		Template and modes
  		retract(+clause)

  		Description
  		Retracts a clause for a dynamic predicate. When the predicate indicator for Head is declared in a uses/2 or use_module/2 directive, the clause is retracted in the referenced object or module. Otherwise the clause is retracted in an object's dynamic predicate. On backtracking, the predicate retracts the next matching clause.

  	'''
  	prefix: "retract"

  "methods:retractall/1":
  	body: '''
  		retractall(${1:Head})$0

  	'''
  	description: '''
  		Template and modes
  		retractall(+callable)

  		Description
  		Retracts all clauses with a matching head for a dynamic predicate. When the predicate indicator for Head is declared in a uses/2 or use_module/2 directive, the clauses are retracted in the referenced object or module. Otherwise the clauses are retracted in an object's dynamic predicate.

  	'''
  	prefix: "retractall"

  "methods:self/1":
  	body: '''
  		self(${1:Self})$0

  	'''
  	description: '''
  		Template and modes
  		self(?object_identifier)

  		Description
  		Returns the object that has received the message under processing. This private method is translated to a unification between its argument and the corresponding implicit context argument in the predicate containing the call. This unification occurs at the clause head when the argument is not instantiated (the most common case).

  	'''
  	prefix: "self"

  "methods:sender/1":
  	body: '''
  		sender(${1:Sender})$0

  	'''
  	description: '''
  		Template and modes
  		sender(?object_identifier)

  		Description
  		Returns the object that has sent the message under processing. This private method is translated into a unification between its argument and the corresponding implicit context argument in the predicate containing the call. This unification occurs at the clause head when the argument is not instantiated (the most common case).

  	'''
  	prefix: "sender"

  "methods:setof/3":
  	body: '''
  		setof(${1:Template}, ${2:Goal}, ${3:List})$0

  	'''
  	description: '''
  		Template and modes
  		setof(@term, +callable, -list)

  		Description
  		Collects a set of solutions for the goal for each set of instantiations of the free variables in the goal. The solutions are sorted using standard term order. The free variables in the goal are the variables that occur in the goal but not in the template. Free variables can be ignored, however, by using the ^/2 existential qualifier. For example, if T is term containing all the free variables that we want to ignore, we can write T^Goal. Note that the term T can be written as V1^V2^....

  	'''
  	prefix: "setof"

  "methods:term_expansion/2":
  	body: '''
  		term_expansion(${1:Term}, ${2:Expansion})$0

  	'''
  	description: '''
  		Template and modes
  		term_expansion(+nonvar, -nonvar)
  		term_expansion(+nonvar, -list(nonvar))

  		Description
  		Defines an expansion for a term. This predicate, when defined and within scope, is automatically called by the expand_term/2 method. When that is not the case, the expand_term/2 method only uses the default expansions. Use of this predicate by the expand_term/2 method may be restricted by changing its default public scope.

  	'''
  	prefix: "term_expansion"

  "methods:this/1":
  	body: '''
  		this(${1:This})$0

  	'''
  	description: '''
  		Template and modes
  		this(?object_identifier)

  		Description
  		Unifies its argument with the identifier of the object for which the predicate clause whose body is being executed is defined (or the object importing the category that contains the predicate clause). This private method is implemented as a unification between its argument and the corresponding implicit execution-context argument in the predicate containing the call. This unification occurs at the clause head when the argument is not instantiated (the most common case). This method is useful for avoiding hard-coding references to an object identifier or for retrieving all object parameters with a single call when using parametric objects. See also parameter/2.

  	'''
  	prefix: "this"

  "methods:throw/1":
  	body: '''
  		throw(${1:Exception})$0

  	'''
  	description: '''
  		Template and modes
  		throw(+nonvar)

  		Description
  		Throws an exception. This built-in predicate is declared as a private method and thus cannot be used as a message to an object.

  	'''
  	prefix: "throw"

  "logtalk_object0":
  	body: '''

  		:- object(${1:Prototype},
  			implements(${2:Protocol}),
  			imports(${3:Category}),
  			extends(${4:Parent})).

  			:- info([
  				version is 1.0,
  				author is '${5:Author}',
  				date is ${6:$CURRENT_YEAR}/${7:$CURRENT_MONTH}/${8:$CURRENT_DATE},
  				comment is '${9:Description}'
  			]).

  		$0

  		:- end_object.

  	'''
  	description: "Prototype with all"
  	prefix: "object0"

  "logtalk_object1":
  	body: '''

  		:- object(${1:Prototype},
  			imports(${2:Category})).

  			:- info([
  				version is 1.0,
  				author is '${3:Author}',
  				date is ${4:$CURRENT_YEAR}/${5:$CURRENT_MONTH}/${6:$CURRENT_DATE},
  				comment is '${7:Description}'
  			]).

  		$0

  		:- end_object.

  	'''
  	description: "Prototype with category"
  	prefix: "object1"

  "logtalk_object2":
  	body: '''

  		:- object(${1:Prototype},
  			extends(${2:Parent})).

  			:- info([
  				version is 1.0,
  				author is '${3:Author}',
  				date is ${4:$CURRENT_YEAR}/${5:$CURRENT_MONTH}/${6:$CURRENT_DATE},
  				comment is '${7:Description}'
  			]).

  		$0

  		:- end_object.

  	'''
  	description: "Prototype with parent"
  	prefix: "object2"

  "logtalk_object3":
  	body: '''

  		:- object(${1:Prototype},
  			implements(${2:Protocol})).

  			:- info([
  				version is 1.0,
  				author is '${3:Author}',
  				date is ${4:$CURRENT_YEAR}/${5:$CURRENT_MONTH}/${6:$CURRENT_DATE},
  				comment is '${7:Description}'
  			]).

  		$0

  		:- end_object.

  	'''
  	description: "Prototype with protocol"
  	prefix: "object3"

  "logtalk_object4":
  	body: '''

  		:- object(${1:Object}).

  			:- info([
  				version is 1.0,
  				author is '${2:Author}',
  				date is ${3:$CURRENT_YEAR}/${4:$CURRENT_MONTH}/${5:$CURRENT_DATE},
  				comment is '${6:Description}'
  			]).

  		$0

  		:- end_object.

  	'''
  	description: "Prototype"
  	prefix: "object4"

  "predicates:abolish_category/1":
  	body: '''
  		abolish_category(${1:Category})$0

  	'''
  	description: '''
  		Template and modes
  		abolish_category(+category_identifier)

  		Description
  		Abolishes a dynamic category.

  	'''
  	prefix: "abolish_category"

  "predicates:abolish_events/5":
  	body: '''
  		abolish_events(${1:Event}, ${2:Object}, ${3:Message}, ${4:Sender}, ${5:Monitor})$0

  	'''
  	description: '''
  		Template and modes
  		abolish_events(@term, @term, @term, @term, @term)

  		Description
  		Abolishes all matching events. The two types of events are represented by the atoms before and after. When the predicate is called with the first argument unbound, both types of events are abolished.

  	'''
  	prefix: "abolish_events"

  "predicates:abolish_object/1":
  	body: '''
  		abolish_object(${1:Object})$0

  	'''
  	description: '''
  		Template and modes
  		abolish_object(+object_identifier)

  		Description
  		Abolishes a dynamic object.

  	'''
  	prefix: "abolish_object"

  "predicates:abolish_protocol/1":
  	body: '''
  		abolish_protocol(${1:Protocol})$0

  	'''
  	description: '''
  		Template and modes
  		abolish_protocol(@protocol_identifier)

  		Description
  		Abolishes a dynamic protocol.

  	'''
  	prefix: "abolish_protocol"

  "predicates:category_property/2":
  	body: '''
  		category_property(${1:Category}, ${2:Property})$0

  	'''
  	description: '''
  		Template and modes
  		category_property(?category_identifier, ?category_property)

  		Description
  		Enumerates, by backtracking, the properties associated with the defined categories. The valid category properties are listed in the language grammar.

  	'''
  	prefix: "category_property"

  "predicates:complements_object/2":
  	body: '''
  		complements_object(${1:Category}, ${2:Object})$0

  	'''
  	description: '''
  		Template and modes
  		complements_object(?category_identifier, ?object_identifier)

  		Description
  		Enumerates, by backtracking, all categoryobject pairs such that the category explicitly complements the object.

  	'''
  	prefix: "complements_object"

  "predicates:conforms_to_protocol/2-3":
  	body: '''
  		conforms_to_protocol(${1:Object}, ${2:Protocol})$0

  	'''
  	description: '''
  		Template and modes
  		conforms_to_protocol(?object_identifier, ?protocol_identifier)
  		conforms_to_protocol(?category_identifier, ?protocol_identifier)

  		conforms_to_protocol(?object_identifier, ?protocol_identifier, ?scope)
  		conforms_to_protocol(?category_identifier, ?protocol_identifier, ?scope)

  		Description
  		Enumerates, by backtracking, all pairs of entities such that an object or a category conforms to a protocol. The relation scope is represented by the atoms public, protected, and private. This predicate implements a transitive closure for the protocol implementation relation.

  	'''
  	prefix: "conforms_to_protocol"

  "predicates:create_category/4":
  	body: '''
  		create_category(${1:Identifier}, ${2:Relations}, ${3:Directives}, ${4:Clauses})$0

  	'''
  	description: '''
  		Template and modes
  		create_category(?category_identifier, +list, +list, +list)

  		Description
  		Creates a new, dynamic category. This predicate is often used as a primitive to implement high-level category creation methods.

  	'''
  	prefix: "create_category"

  "predicates:create_logtalk_flag/3":
  	body: '''
  		create_logtalk_flag(${1:Flag}, ${2:Value}, ${3:Options})$0

  	'''
  	description: '''
  		Template and modes
  		create_logtalk_flag(+atom, +ground, +list(ground))

  		Description
  		Creates a new Logtalk flag and sets its default value. User-defined flags can be queried and set in the same way as pre-defined flags by using, respectively, the current_logtalk_flag/2 and set_logtalk_flag/2 built-in predicates.

  	'''
  	prefix: "create_logtalk_flag"

  "predicates:create_object/4":
  	body: '''
  		create_object(${1:Identifier}, ${2:Relations}, ${3:Directives}, ${4:Clauses})$0

  	'''
  	description: '''
  		Template and modes
  		create_object(?object_identifier, +list, +list, +list)

  		Description
  		Creates a new, dynamic object. The word object is used here as a generic term. This predicate can be used to create new prototypes, instances, and classes. This predicate is often used as a primitive to implement high-level object creation methods.

  	'''
  	prefix: "create_object"

  "predicates:create_protocol/3":
  	body: '''
  		create_protocol(${1:Identifier}, ${2:Relations}, ${3:Directives})$0

  	'''
  	description: '''
  		Template and modes
  		create_protocol(?protocol_identifier, +list, +list)

  		Description
  		Creates a new, dynamic, protocol. This predicate is often used as a primitive to implement high-level protocol creation methods.

  	'''
  	prefix: "create_protocol"

  "predicates:current_category/1":
  	body: '''
  		current_category(${1:Category})$0

  	'''
  	description: '''
  		Template and modes
  		current_category(?category_identifier)

  		Description
  		Enumerates, by backtracking, all currently defined categories. All categories are found, either static, dynamic, or built-in.

  	'''
  	prefix: "current_category"

  "predicates:current_event/5":
  	body: '''
  		current_event(${1:Event}, ${2:Object}, ${3:Message}, ${4:Sender}, ${5:Monitor})$0

  	'''
  	description: '''
  		Template and modes
  		current_event(?event, ?term, ?term, ?term, ?object_identifier)

  		Description
  		Enumerates, by backtracking, all defined events. The two types of events are represented by the atoms before and after.

  	'''
  	prefix: "current_event"

  "predicates:current_logtalk_flag/2":
  	body: '''
  		current_logtalk_flag(${1:Flag}, ${2:Value})$0

  	'''
  	description: '''
  		Template and modes
  		current_logtalk_flag(?atom, ?atom)

  		Description
  		Enumerates, by backtracking, the current Logtalk flag values.

  	'''
  	prefix: "current_logtalk_flag"

  "predicates:current_object/1":
  	body: '''
  		current_object(${1:Object})$0

  	'''
  	description: '''
  		Template and modes
  		current_object(?object_identifier)

  		Description
  		Enumerates, by backtracking, all currently defined objects. All objects are found, either static, dynamic or built-in.

  	'''
  	prefix: "current_object"

  "predicates:current_protocol/1":
  	body: '''
  		current_protocol(${1:Protocol})$0

  	'''
  	description: '''
  		Template and modes
  		current_protocol(?protocol_identifier)

  		Description
  		Enumerates, by backtracking, all currently defined protocols. All protocols are found, either static, dynamic, or built-in.

  	'''
  	prefix: "current_protocol"

  "predicates:define_events/5":
  	body: '''
  		define_events(${1:Event}, ${2:Object}, ${3:Message}, ${4:Sender}, ${5:Monitor})$0

  	'''
  	description: '''
  		Template and modes
  		define_events(@term, @term, @term, @term, +object_identifier)

  		Description
  		Defines a new set of events. The two types of events are represented by the atoms before and after. When the predicate is called with the first argument unbound, both types of events are defined. The object Monitor must define the event handler methods required by the Event argument.

  	'''
  	prefix: "define_events"

  "predicates:extends_category/2-3":
  	body: '''
  		extends_category(${1:Category1}, ${2:Category2})$0

  	'''
  	description: '''
  		Template and modes
  		extends_category(?category_identifier, ?category_identifier)
  		extends_category(?category_identifier, ?category_identifier, ?scope)

  		Description
  		Enumerates, by backtracking, all pairs of categories such that the first one extends the second. The relation scope is represented by the atoms public, protected, and private.

  	'''
  	prefix: "extends_category"

  "predicates:extends_object/2-3":
  	body: '''
  		extends_object(${1:Prototype}, ${2:Parent})$0

  	'''
  	description: '''
  		Template and modes
  		extends_object(?object_identifier, ?object_identifier)
  		extends_object(?object_identifier, ?object_identifier, ?scope)

  		Description
  		Enumerates, by backtracking, all pairs of objects such that the first one extends the second. The relation scope is represented by the atoms public, protected, and private.

  	'''
  	prefix: "extends_object"

  "predicates:extends_protocol/2-3":
  	body: '''
  		extends_protocol(${1:Protocol1}, ${2:Protocol2})$0

  	'''
  	description: '''
  		Template and modes
  		extends_protocol(?protocol_identifier, ?protocol_identifier)
  		extends_protocol(?protocol_identifier, ?protocol_identifier, ?scope)

  		Description
  		Enumerates, by backtracking, all pairs of protocols such that the first one extends the second. The relation scope is represented by the atoms public, protected, and private.

  	'''
  	prefix: "extends_protocol"

  "predicates:implements_protocol/2-3":
  	body: '''
  		implements_protocol(${1:Object}, ${2:Protocol})$0

  	'''
  	description: '''
  		Template and modes
  		implements_protocol(?object_identifier, ?protocol_identifier)
  		implements_protocol(?category_identifier, ?protocol_identifier)

  		implements_protocol(?object_identifier, ?protocol_identifier, ?scope)
  		implements_protocol(?category_identifier, ?protocol_identifier, ?scope)

  		Description
  		Enumerates, by backtracking, all pairs of entities such that an object or a category implements a protocol. The relation scope is represented by the atoms public, protected, and private. This predicate only returns direct implementation relations; it does not implement a transitive closure.

  	'''
  	prefix: "implements_protocol"

  "predicates:imports_category/2-3":
  	body: '''
  		imports_category(${1:Object}, ${2:Category})$0

  	'''
  	description: '''
  		Template and modes
  		imports_category(?object_identifier, ?category_identifier)

  		imports_category(?object_identifier, ?category_identifier, ?scope)

  		Description
  		Enumerates, by backtracking, importation relations between objects and categories. The relation scope is represented by the atoms public, protected, and private.

  	'''
  	prefix: "imports_category"

  "predicates:instantiates_class/2-3":
  	body: '''
  		instantiates_class(${1:Instance}, ${2:Class})$0

  	'''
  	description: '''
  		Template and modes
  		instantiates_class(?object_identifier, ?object_identifier)
  		instantiates_class(?object_identifier, ?object_identifier, ?scope)

  		Description
  		Enumerates, by backtracking, all pairs of objects such that the first one instantiates the second. The relation scope is represented by the atoms public, protected, and private.

  	'''
  	prefix: "instantiates_class"

  "predicates:logtalk_compile/1":
  	body: '''
  		logtalk_compile(${1:File})$0

  	'''
  	description: '''
  		Template and modes
  		logtalk_compile(@source_file_name)
  		logtalk_compile(@list(source_file_name))

  		Description
  		Compiles to disk a source file or a list of source files using the current default compiler flag values. The Logtalk source file name extension (by default, .lgt) can be omitted. Source file paths can be absolute, relative to the current directory, or use library notation. This predicate can also be used to compile Prolog source files as Logtalk source code. When no recognized Logtalk or Prolog extension is specified, the compiler tries first to append a Logtalk source file extension and then a Prolog source file extension. If that fails, the compiler tries to use the file name as-is.

  	'''
  	prefix: "logtalk_compile1"

  "predicates:logtalk_compile/2":
  	body: '''
  		logtalk_compile(${1:File}, ${2:Flags})$0

  	'''
  	description: '''
  		Template and modes
  		logtalk_compile(@source_file_name, @list(compiler_flag))
  		logtalk_compile(@list(source_file_name), @list(compiler_flag))

  		Description
  		Compiles to disk a  source file or a list of source files using a list of compiler flags. The Logtalk source file name extension (by default, .lgt) can be omitted. Source file paths can be absolute, relative to the current directory, or use library notation. This predicate can also be used to compile Prolog source files as Logtalk source code. When no recognized Logtalk or Prolog extension is specified, the compiler tries first to append a Logtalk source file extension and then a Prolog source file extension. If that fails, the compiler tries to use the file name as-is. Compiler flags are represented as flag(value). For a description of the available compiler flags, please consult the User Manual.

  	'''
  	prefix: "logtalk_compile2"

  "predicates:logtalk_library_path/2":
  	body: '''
  		logtalk_library_path(${1:Library}, ${2:Path})$0

  	'''
  	description: '''
  		Template and modes
  		logtalk_library_path(?atom, -atom)
  		logtalk_library_path(?atom, -compound)

  		Description
  		Dynamic and multifile user-defined predicate, allowing the declaration of aliases to library paths. Library aliases may also be used on the second argument (using the notation alias(path)). Paths must always end with the path directory separator character ('/').

  	'''
  	prefix: "logtalk_library_path"

  "predicates:logtalk_load/1":
  	body: '''
  		logtalk_load(${1:File})$0

  	'''
  	description: '''
  		Template and modes
  		logtalk_load(@source_file_name)
  		logtalk_load(@list(source_file_name))

  		Description
  		Compiles to disk and then loads to memory a source file or a list of source files using the current default compiler flag values. The Logtalk source file name extension (by default, .lgt) can be omitted. Source file paths can be absolute, relative to the current directory, or use library notation. This predicate can also be used to compile Prolog source files as Logtalk source code. When no recognized Logtalk or Prolog extension is specified, the compiler tries first to append a Logtalk source file extension and then a Prolog source file extension. If that fails, the compiler tries to use the file name as-is.

  	'''
  	prefix: "logtalk_load1"

  "predicates:logtalk_load/2":
  	body: '''
  		logtalk_load(${1:File}, ${2:Flags})$0

  	'''
  	description: '''
  		Template and modes
  		logtalk_load(@source_file_name, @list(compiler_flag))
  		logtalk_load(@list(source_file_name), @list(compiler_flag))

  		Description
  		Compiles to disk and then loads to memory a source file or a list of source files using a list of compiler flags. The Logtalk source file name extension (by default, .lgt) can be omitted. Compiler flags are represented as flag(value). This predicate can also be used to compile Prolog source files as Logtalk source code. When no recognized Logtalk or Prolog extension is specified, the compiler tries first to append a Logtalk source file extension and then a Prolog source file extension. If that fails, the compiler tries to use the file name as-is. For a description of the available compiler flags, please consult the User Manual. Source file paths can be absolute, relative to the current directory, or use library notation.

  	'''
  	prefix: "logtalk_load2"

  "predicates:logtalk_load_context/2":
  	body: '''
  		logtalk_load_context(${1:Key}, ${2:Value})$0

  	'''
  	description: '''
  		Template and modes
  		logtalk_load_context(?atom, -nonvar)

  		Description
  		Provides access to the Logtalk compilation/loading context. The following keys are currently supported: entity_identifier, entity_prefix, entity_type (returns the value module when compiling a module as an object), source, file (the actual file being compiled, which is different from source only when processing an include/1 directive), basename, directory, stream, target (the full path of the intermediate Prolog file), flags (the list of the explicit flags used for the compilation of the source file), term (the term being expanded), term_position (StartLine-EndLine), and variable_names ([Name1=Variable1, ...]). The term_position key is only supported in back-end Prolog compilers that provide access to the start and end lines of a read term.

  	'''
  	prefix: "logtalk_load_context"

  "predicates:logtalk_make/0":
  	body: '''
  		logtalk_make$0$0

  	'''
  	description: '''
  		Template and modes
  		logtalk_make

  		Description
  		Reloads all Logtalk source files that have been modified since the time they are last loaded. Only source files loaded using the logtalk_load/1-2 predicates are reloaded. Non-modified files will also be reloaded when there is a change to the compilation mode (i.e. when the files were loaded without explicit debug/1 or optimize/1 flags and the default values of these flags changed after loading; no check is made, however, for other implicit compiler flags that may have changed since loading). When an included file is modified, this predicate reloads its main file (i.e. the file that contains the include/1 directive).

  	'''
  	prefix: "logtalk_make0"

  "predicates:logtalk_make/1":
  	body: '''
  		logtalk_make(${1:Target})$0

  	'''
  	description: '''
  		Template and modes
  		logtalk_make(+atom)

  		Description
  		Allows reloading all Logtalk source files that have been modified since last loaded when called with the target all, deleting all intermediate files generated by the compilation of Logtalk source files when called with the target clean, checking for code issues when called with the target check, and listing of circular dependencies between pairs or trios of objects when called with the target circular.

  	'''
  	prefix: "logtalk_make1"

  "predicates:object_property/2":
  	body: '''
  		object_property(${1:Object}, ${2:Property})$0

  	'''
  	description: '''
  		Template and modes
  		object_property(?object_identifier, ?object_property)

  		Description
  		Enumerates, by backtracking, the properties associated with the defined objects. The valid object properties are listed in the language grammar.

  	'''
  	prefix: "object_property2"

  "predicates:protocol_property/2":
  	body: '''
  		protocol_property(${1:Protocol}, ${2:Property})$0

  	'''
  	description: '''
  		Template and modes
  		protocol_property(?protocol_identifier, ?protocol_property)

  		Description
  		Enumerates, by backtracking, the properties associated with the currently defined protocols. The valid protocol properties are listed in the language grammar.

  	'''
  	prefix: "protocol_property"

  "predicates:set_logtalk_flag/2":
  	body: '''
  		set_logtalk_flag(${1:Flag}, ${2:Value})$0

  	'''
  	description: '''
  		Template and modes
  		set_logtalk_flag(+atom, +nonvar)

  		Description
  		Sets Logtalk default, global, flag values. For local flag scope, use the corresponding set_logtalk_flag/2 directive. To set a global flag value when compiling and loading a source file, wrap the calls to this built-in predicate with an initialization/1 directive.

  	'''
  	prefix: "set_logtalk_flag"

  "predicates:specializes_class/2-3":
  	body: '''
  		specializes_class(${1:Class}, ${2:Superclass})$0

  	'''
  	description: '''
  		Template and modes
  		specializes_class(?object_identifier, ?object_identifier)
  		specializes_class(?object_identifier, ?object_identifier, ?scope)

  		Description
  		Enumerates, by backtracking, all pairs of objects such that the first one specializes the second. The relation scope is represented by the atoms public, protected, and private.

  	'''
  	prefix: "specializes_class"

  "predicates:threaded/1":
  	body: '''
  		threaded(${1:Goals})$0

  	'''
  	description: '''
  		Template and modes
  		threaded(+callable)

  		Description
  		Proves each goal in a conjunction (disjunction) of goals in its own thread. This predicate is deterministic and opaque to cuts. The predicate argument is not flattened.

  	'''
  	prefix: "threaded1"

  "predicates:threaded_call/1-2":
  	body: '''
  		threaded_call(${1:Goal})$0

  	'''
  	description: '''
  		Template and modes
  		threaded_call(@callable)
  		threaded_call(@callable, -nonvar)

  		Description
  		Proves Goal asynchronously using a new thread. The argument can be a message sending goal. Calls to this predicate always succeeds and return immediately. The results (success, failure, or exception) are sent back to the message queue of the object containing the call (this); they can be retrieved by calling the threaded_exit/1 predicate.

  	'''
  	prefix: "threaded_call"

  "predicates:threaded_engine/1":
  	body: '''
  		threaded_engine(${1:Engine})$0

  	'''
  	description: '''
  		Template and modes
  		threaded_engine(?nonvar)

  		Description
  		Enumerates, by backtracking, all existing engines.

  	'''
  	prefix: "threaded_engine"

  "predicates:threaded_engine_create/3":
  	body: '''
  		threaded_engine_create(${1:AnswerTemplate}, ${2:Goal}, ${3:Engine})$0

  	'''
  	description: '''
  		Template and modes
  		threaded_engine_create(@term, @callable, ?nonvar)

  		Description
  		Creates a new engine for proving the given goal and defines an answer template for retrieving the goal solution bindings. A message queue for passing arbitrary terms to the engine is also created. If the name for the engine is not given, a unique name is generated and returned.

  	'''
  	prefix: "threaded_engine_create"

  "predicates:threaded_engine_destroy/1":
  	body: '''
  		threaded_engine_destroy(${1:Engine})$0

  	'''
  	description: '''
  		Template and modes
  		threaded_engine_destroy(@nonvar)

  		Description
  		Stops an engine.

  	'''
  	prefix: "threaded_engine_destroy"

  "predicates:threaded_engine_fetch/1":
  	body: '''
  		threaded_engine_fetch(${1:Term})$0

  	'''
  	description: '''
  		Template and modes
  		threaded_engine_fetch(?term)

  		Description
  		Fetches a term from the engine term queue. Blocks until a term is available. Fails in not called from within an engine.

  	'''
  	prefix: "threaded_engine_fetch"

  "predicates:threaded_engine_next/2":
  	body: '''
  		threaded_engine_next(${1:Engine}, ${2:Answer})$0

  	'''
  	description: '''
  		Template and modes
  		threaded_engine_next(@nonvar, ?term)

  		Description
  		Retrieves the next answer from an engine. This predicate blocks until an answer becomes available. The predicate fails when there are no more solutions to the engine goal. If the engine goal throws an exception, calling this predicate will re-throw the exception and subsequent calls will fail.

  	'''
  	prefix: "threaded_engine_next"

  "predicates:threaded_engine_next_reified/2":
  	body: '''
  		threaded_engine_next_reified(${1:Engine}, ${2:Answer})$0

  	'''
  	description: '''
  		Template and modes
  		threaded_engine_next_reified(@nonvar, ?nonvar)

  		Description
  		Retrieves the next reified answer from an engine. This predicate predicate always succeeds and blocks until an answer becomes available. Answers are returned using the terms the(Answer), no, and exception(Error).

  	'''
  	prefix: "threaded_engine_next_reified"

  "predicates:threaded_engine_post/2":
  	body: '''
  		threaded_engine_post(${1:Engine}, ${2:Term})$0

  	'''
  	description: '''
  		Template and modes
  		threaded_engine_post(@nonvar, @term)

  		Description
  		Posts a term to the engine term queue.

  	'''
  	prefix: "threaded_engine_post"

  "predicates:threaded_engine_self/1":
  	body: '''
  		threaded_engine_self(${1:Engine})$0

  	'''
  	description: '''
  		Template and modes
  		threaded_engine_self(?nonvar)

  		Description
  		Queries the name of engine calling the predicate.

  	'''
  	prefix: "threaded_engine_self"

  "predicates:threaded_engine_yield/1":
  	body: '''
  		threaded_engine_yield(${1:Answer})$0

  	'''
  	description: '''
  		Template and modes
  		threaded_engine_yield(@term)

  		Description
  		Returns an answer independent of the solutions of the engine goal. Fails if not called from within an engine. This predicate is usually used when the engine goal is call to a recursive predicate processing terms from the engine term queue.

  	'''
  	prefix: "threaded_engine_yield"

  "predicates:threaded_exit/1-2":
  	body: '''
  		threaded_exit(${1:Goal})$0

  	'''
  	description: '''
  		Template and modes
  		threaded_exit(+callable)
  		threaded_exit(+callable, +nonvar)

  		Description
  		Retrieves the result of proving Goal in a new thread. This predicate blocks execution until the reply is sent to the this message queue by the thread executing the goal. When there is no thread proving the goal, the predicate generates an exception. This predicate is non-deterministic, providing access to any alternative solutions of its argument.

  	'''
  	prefix: "threaded_exit"

  "predicates:threaded_ignore/1":
  	body: '''
  		threaded_ignore(${1:Goal})$0

  	'''
  	description: '''
  		Template and modes
  		threaded_ignore(@callable)

  		Description
  		Proves Goal asynchronously using a new thread. Only the first goal solution is found. The argument can be a message sending goal. This call always succeeds, independently of the result (success, failure, or exception), which is simply discarded instead of being sent back to the message queue of the object containing the call (this).

  	'''
  	prefix: "threaded_ignore"

  "predicates:threaded_notify/1":
  	body: '''
  		threaded_notify(${1:Term})$0

  	'''
  	description: '''
  		Template and modes
  		threaded_notify(@term)
  		threaded_notify(@list(term))

  		Description
  		Sends Term as a notification to any thread suspended waiting for it in order to proceed. The call must be made within the same object (this) containing the calls to the threaded_wait/1 predicate waiting for the notification. The argument may also be a list of notifications, [Term| Terms]. In this case, all notifications in the list will be sent to any threads suspended waiting for them in order to proceed.

  	'''
  	prefix: "threaded_notify"

  "predicates:threaded_once/1-2":
  	body: '''
  		threaded_once(${1:Goal})$0

  	'''
  	description: '''
  		Template and modes
  		threaded_once(@callable)
  		threaded_once(@callable, -nonvar)

  		Description
  		Proves Goal asynchronously using a new thread. Only the first goal solution is found. The argument can be a message sending goal. This call always succeeds. The result (success, failure, or exception) is sent back to the message queue of the object containing the call (this).

  	'''
  	prefix: "threaded_once"

  "predicates:threaded_peek/1-2":
  	body: '''
  		threaded_peek(${1:Goal})$0

  	'''
  	description: '''
  		Template and modes
  		threaded_peek(+callable)
  		threaded_peek(+callable, +nonvar)

  		Description
  		Checks if the result of proving Goal in a new thread is already available. This call succeeds or fails without blocking execution waiting for a reply to be available.

  	'''
  	prefix: "threaded_peek"

  "predicates:threaded_wait/1":
  	body: '''
  		threaded_wait(${1:Term})$0

  	'''
  	description: '''
  		Template and modes
  		threaded_wait(?term)
  		threaded_wait(+list(term))

  		Description
  		Suspends the thread making the call until a notification is received that unifies with Term. The call must be made within the same object (this) containing the calls to the threaded_notify/1 predicate that will eventually send the notification. The argument may also be a list of notifications, [Term| Terms]. In this case, the thread making the call will suspend until all notifications in the list are received.

  	'''
  	prefix: "threaded_wait"

  "private0":
  	body: '''
  			:- private(${1:Functor}/0).
  			:- mode(${1:Functor}, ${2:Solutions}).
  			:- info(${1:Functor}/0, [
  				comment is '${3:Description}'
  			]).

  		$0
  	'''
  	description: "(with no arguments)"
  	prefix: "private0"

  "private3":
  	body: '''
  			:- private(${1:Functor}/${2:Arity}).
  			:- mode(${1:Functor}(${3:Arguments}), ${4:Solutions}).
  			:- info(${1:Functor}/${2:Arity}, [
  				comment is '${5:Description}',
  				arguments is ['$6'-'$7']
  			]).

  		$0
  	'''
  	description: "Private predicate"
  	prefix: "private3"

  "protected0":
  	body: '''
  			:- protected(${1:Functor}/0).
  			:- mode(${1:Functor}, ${2:Solutions}).
  			:- info(${1:Functor}/0, [
  				comment is '${3:Description}'
  			]).

  		$0
  	'''
  	description: "(with no arguments)"
  	prefix: "protected0"

  "protected1":
  	body: '''
  			:- protected(${1:Functor}/${2:Arity}).
  			:- mode(${1:Functor}(${3:Arguments}), ${4:Solutions}).
  			:- info(${1:Functor}/${2:Arity}, [
  				comment is '${5:Description}',
  				arguments is ['$6'-'$7']
  			]).

  		$0
  	'''
  	description: "Protected predicate"
  	prefix: "protected1"

  "protocol0":
  	body: '''

  		:- protocol(${1:Extended},
  			extends(${2:Minimal})).

  			:- info([
  				version is 1.0,
  				author is '${3:Author}',
  				date is ${4:$CURRENT_YEAR}/${5:$CURRENT_MONTH}/${6:$CURRENT_DATE},
  				comment is '${7:Description}'
  			]).

  		$0

  		:- end_protocol.

  	'''
  	description: "Extended protocol"
  	prefix: "protocol0"

  "protocol1":
  	body: '''

  		:- protocol(${1:Protocol}).

  			:- info([
  				version is 1.0,
  				author is '${2:Author}',
  				date is ${3:$CURRENT_YEAR}/${4:$CURRENT_MONTH}/${5:$CURRENT_DATE},
  				comment is '${6:Description}'
  			]).

  		$0

  		:- end_protocol.

  	'''
  	description: "Protocol"
  	prefix: "protocol1"

  "public0":
  	body: '''
  			:- public(${1:Functor}/0).
  			:- mode(${1:Functor}, ${2:Solutions}).
  			:- info(${1:Functor}/0, [
  				comment is '${3:Description}'
  			]).

  		$0
  	'''
  	description: "(with no arguments)"
  	prefix: "public0"

  "public1":
  	body: '''
  			:- public(${1:Functor}/${2:Arity}).
  			:- mode(${1:Functor}(${3:Arguments}), ${4:Solutions}).
  			:- info(${1:Functor}/${2:Arity}, [
  				comment is '${5:Description}',
  				arguments is ['$6'-'$7']
  			]).

  		$0
  	'''
  	description: "Public predicate"
  	prefix: "public1"

  "directive:object1":
  	prefix: "if"
  	body: ":-"

  "directive:object2":
  	prefix: "and"
  	body: ","

  "directive:object3":
  	prefix: "null"
  	body: "false"

  "directive:object4":
  	prefix: "tuple"
  	body: "( a, b, c )"

  "directive:object5":
  	prefix: "dictionary"
  	body: "findall(Key, item(Key, _), Keys)"

  "directive:object6":
  	prefix: "upper-case"
  	body: "char_type(C_, to_upper(C))"

  "directive:object7":
  	prefix: "lower-case"
  	body: "char_type(C_, to_lower(C))"

  "directive:object8":
  	prefix: "upper-string"
  	body: "upcase_atom()"

  "directive:object9":
  	prefix: "lower-string"
  	body: "downcase_atom"
